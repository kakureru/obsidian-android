#kotlin

Легковесные потоки. Не такие тяжелые как Threads. 

Coroutine — это блоки кода, которые работают асинхронно, то есть по очереди. В нужный момент исполнение такого блока приостанавливается с сохранением всех его свойств, чтобы запустился другой код. Когда управление возвращается к первому блоку, он продолжает работу. В результате программа выполняет несколько функций одновременно.

### Различия между корутинами и потоками

Многозадачность с использованием корутин легко перепутать с многопоточностью. Это выполнение программы в нескольких системных потоках.

Поток — составная часть процесса, который выполняется в операционной системе. Принцип похож: несколько потоков останавливаются и возобновляются, ждут друг друга, общаются. Но есть отличия.

- Потоками управляет операционная система. Переключением корутин — разработчик с помощью кода.
- Потоки отнимают много ресурсов процессора. Корутины не требуют переключения контекста, поэтому код потребляет мало ресурсов.
- Потоки ускоряют выполнение сложной задачи, но отнимают много ресурсов. Корутины не повышают скорость, но помогают оптимизировать нагрузку.
- Корутины выполняются в рамках одного потока или пула потоков.

![[Coroutines vs Threads.png]]

runBlocking { } - запускает корутину, которая блокирует поток, пока не будут выполнены все операции в этом блоке

Для запуска корутин используются [[Coroutine Builders]]

## Обработка ошибок

- Необработанная ошибка вызовет Thread.UncaughtExceptionHandler
- Все необработанные исключения будут доставляться родительской корутине вплоть до скоупа и приводить к остановке с ошибкой (если не используется SupervisorJob. 

``` kotlin
launch {
	try {
		doSomething()
	} catch (e: CancellationException) {
		throw e
	} catch (e: Exception) {
		// processing
	}
}

val deferred: Deferred<Any> = async { doSomething() }
try {
	deferred.await()
} catch (e: CancellationException) {
	throw e
} catch (e: Exception) {
	// processing
}
```

Однако даже если мы обработаем ошибку, всё равно упадёт родительская Job! Для предотвращения этого, можно обернуть рисковый код в supervisorScope