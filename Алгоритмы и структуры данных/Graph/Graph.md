## Методы обхода

- [[Graph BFS]]
- [[Graph DFS]]

## Построение графа

``` kotlin
edges = [[0,1],[1,2],[2,0]]
```

Двунаправленный:
``` kotlin
fun buildGraph(n: Int, edges: Array<IntArray>): List<ArrayList<Int>> {  
    val graph = List(n) { arrayListOf<Int>() }  
    for (e in edges) {  
        graph[e[0]].add(e[1])  
        graph[e[1]].add(e[0])  
    }  
    return graph  
}
```

Однонаправленный:
``` kotlin
fun buildGraph(n: Int, edges: Array<IntArray>): List<ArrayList<Int>> {  
    val graph = List(n) { arrayListOf<Int>() }  
    for (e in edges) 
	    graph[e[0]].add(e[1])  
    return graph  
}
```

## Представление графа

#### Матрица смежности

Этот способ является удобным для представления **плотных** графов, в которых количество рёбер примерно равно количеству вершин в квадрате.
В данном представлении мы заполняем матрицу размером |V| x |V| следущим образом:  
`A[i][j] = 1 (Если существует ребро из i в j)`
`A[i][j] = 0 (Иначе)`
Данный способ подходит для ориентированных и неориентированных графов. Для неориентированных графов матрица A является симметричной. Благодаря этому свойству можно сократить почти в два раза использование памяти, храня элементы только в верхней части матрицы, над главной диагональю)  
Понятно что с помощью данного способа представления, можно быстро проверить есть ли ребро между вершинами v и u, просто посмотрев в ячейку `A[v][u]`.  
С другой стороны этот способ очень громоздкий, так как требует O (V^2) памяти для хранения матрицы.  
  
![Рис. 2](https://habrastorage.org/r/w1560/getpro/habr/post_images/111/08c/1bf/11108c1bf6685d9f7fc27e6238d61fd0.png)  
  
#### Списки смежности

Данный способ представления больше подходит для разреженных графов, то есть графов у которых количество рёбер гораздо меньше чем количество вершин в квадрате.
В данном представлении используется массив Adj содержащий V списков. В каждом списке `Adj[v]` содержатся все вершины u, так что между v и u есть ребро. 
Память требуемая для представления равна O (E + V) что является лучшим показателем чем матрица смежности для разреженных графов.  
Главный недостаток этого способа в том, что нет быстрого способа проверить существует ли ребро (u, v). 
  
![Рис. 3](https://habrastorage.org/r/w1560/getpro/habr/post_images/0bc/3d1/e43/0bc3d1e4374c40e3408bcf26e05fba4f.png)  